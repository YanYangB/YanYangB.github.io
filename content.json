{"pages":[{"title":"","text":"Sorry, nothing here. This page will be filled later.","link":"/about/index.html"}],"posts":[{"title":"Ubuntu无root安装软件","text":"Linux下非root用户安装软件的一般流程: 下载源代码，通过wget或者url下载； 解压源代码安装包，一般为tar.gz，对应命令为tar -zxvf xxxxx.tar.gz； 切换到解压后的目录，运行./configure --prefix=/path/to/install，使用./configure --help可以列出可用选项，其中--prefix就是配置安装目录。例如：./configure --prefix=/home/xxx/.local； 编译源码并安装，make -j &amp;&amp; make install，-j参数是并行编译，提高编译速度； 变更环境变量，在.zshrc或者.bashrc中加入export。","link":"/2019/10/01/Ubuntu%E6%97%A0root%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"title":"Step up to Linux","text":"记录Linux的安装与Deep Learning配置过程安装为Ubuntu单系统 1.准备 下载Ubuntu镜像, 建议下载LTS版本。(官网下载速度较慢时考虑清华镜像) 制作启动盘, 建议使用Rufus,操作简单，在制作时要格式化Ｕ盘，先做好Ｕ盘备份工作。 若要安装双系统，还要清理出一块磁盘空间，参考知乎文章 2.安装(以DELL为例) 插入Ｕ盘，启动过程中出现DELL徽标时，快速按F12键。跳转至Boot Once（启动一次）菜单。通过键盘选择U盘所在的UEFI启动方式。同时，有些人建议按F2进入BIOS，将Security选项中的Secure Boot设置为Disabled。 选择语言，键盘布局，一路Next就好，在选择网络时不建议联网，建议正常安装并且为图形或无线硬件以及其他媒体格式安装第三方软件，在安装类型时，前两个选项会自动分区安装，省时省心，但这里推荐自己手动分区，这样可以熟悉自己的分区方便后续管理，因此这里我们选择其他选项 接下来我们需要手动分区(自动分区即可跳过次步骤)。以本人电脑为例，128G固态，500G机械 EFI分区 512M SSD 主分区 空间起始位置 (用作EFI启动，512M足够) /（根目录） SSD剩余空间 主分区 空间起始位置 交换分区 8G 机械硬盘 主分区 空间起始位置 (按照内存大小来设置，一般为内存大小的两倍，但也不至于过大，本机内存12G) /home（家目录） 机械硬盘剩余空间 逻辑分区 空间起始位置 (存放个人文件，越大越好) 注意: 安装启动引导器的设备选择为EFI分区对应的位置 Format选项记得要勾上！ 等待安装完成 … … 享用全新的Ubuntu Ｏ（∩＿∩）Ｏ～～ 3.配置 美化 一个赏心悦目的界面能给人工作的欲望 此处的美化强烈推荐知乎专栏世上最良心***，按照文章一步步来就能打造很美观的界面 注意:不要操作文章开头关于安装显卡驱动的部分，我们会在后续安装 Deep Learning 配置Ubuntu18.04自带Python3.6，在安装pip之前，建议安装几个依赖包: sudo apt install build-essential python3-dev python3-setuptools 安装NVIDIA驱动 查看本机显卡型号: 使用命令lshw -c video查看机器的显卡型号，根据显卡型号去NVIDIA官网下载最新的驱动程序 屏蔽Nouveau驱动: 由于系统自带了nouveau的开源驱动，在安装NVIDIA驱动前要先将其屏蔽 新增系统黑名单: sudo touch /etc/modprobe.d/blacklist-nouveau.conf 在blacklist-nouveau.conf中编辑: 12blacklist nouveauoptions nouveau modeset=0 保存，退出，然后更新initramfs: sudo update-initramfs -u 重启电脑: reboot 查看是否禁用成功: lsmod | grep nouveau，若没有输出，则表明禁用成功 停止可视化界面: sudo telinit 3，需要重新输入用户名和密码 运行下载的run文件: sudo bash NVIDIA-Linux-x86_64*****.run，大部分选择默认提示即可，在GCC版本不匹配时，我选择了忽略，依然可以安装运行成功，目前还没有遇到问题 安装完成后重启，运行nvidia-smi可以看到NVIDIA的输出即表明安装成功 安装cuda 去CUDA官网下载所需要的版本，需要结合深度学习框架（TensorFlow，PyTorch等）对cuda的要求来选择 建议在安装前阅读官方的document，以cuda10.0为例，其中比较有建设性的为这里 运行安装文件: sudo sh cuda_10.0******_linux.run 注意: 运行后在提示是否安装驱动时(Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?)，选择否，因为前面我们已经安装了最新的驱动 安装完成后，将以下命令加入到~/.bashrc当中，以改变环境变量(摘抄自官方document)12export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 验证 重启后在命令行输入nvcc -V，能够输出版本信息 进入家目录下的NVIDIA-SAMPLES，编译运行deviceQuery，输出Result = PASS则证明安装成功 安装cuDNN 去cuDNN官网下载相应版本的cuDNN Library for Linux，需要注册一个账号，建议阅读官方文档 根据安装文档说明，解压.tgz并移动到相应的位置即可 至此，Deep Learning的配置完成","link":"/2019/09/27/Step-up-to-Linux/"},{"title":"SSH Tunnel: Local and Remote Port Forwarding","text":"About SSHssh stands for Secure Shell. It is a protocol used to securely connect to a remote server/system. ssh is secure in the sense that it transfers the data in encrypted form between the host and the client. For deep learning researchers, they usually use ssh to login their remote servers which have high-performance GPUs to train models. Besides its normal usage, it can be used to build tunnel to achieve local port forwarding and remote port forwarding (i.e. forwarding connections to port on machine to port on machine ). With the help of port forwarding, we can do something technically (e.g. passing firewall). In Linux, the ssh command is convenient to achieve these functions. Local Port ForwardingLocal port forwarding is used to forward connections on a local port to another remote port on a different machine. Then all requests to the local port will be sent to the remote port by ssh tunnel. Saying that we have a web server running in machine but it only allows requests from localhost(127.0.0.1). we want to visit this website on we own machine . If we type https://IP_of_machine_B:port in the browser URL bar, the connection will be refused of course. Then we need local port forwarding. The syntax of ssh local port forwarding is : ssh -fNTL local_port:remote_host:remote_port user@ssh_host -f means let ssh to go to background just before command execution. So when type this command in local shell and type ENTER, it will return to the shell and we can do other things. -N means do not execute a remote command. This is useful for just forwarding ports. -T means disable pseudo-terminal allocation and it will save resource on both local and remote machine. -L is the main parameter and it is used for Local port forwarding. Connections to local_port on localhost will be forwarded to remote_port on remote_host by ssh_host. The remote_host we want to request can be the same as ssh_host or not. For example, we have an application running in a host named app.com on port 8888, which is accessible only from the ssh_host server. Then we can request this application by ssh -fNTL 9999:app.com:8888 user@ssh_host. In this way, we type https://127.0.0.1:9999 on wer local browser URL bar and the connection will get forwarded to app.com:8888 by ssh_host and we’ll visit the application successfully. E.g. Visit Remote TensorboardTensorboard is an amazing tool to visualize the process of neural network model training. Training models in a remote server with high-performance GPUs but no GUI is familiar to DL researchers, and the tensorboard application will be deployed in the remote server, which cannot be visited by IP and port from our local browser (we don’t consider the tensorboard settings which may change its accessibility). Suppose the remote server named gpu_server and tensorboard listen on port 6006. We can login the server as user yy. So the command we used is: ssh -fNTL 16006:localhost:6006 yy@gpu_server When we type https://127.0.0.1:16006 in the browser URL bar, the connection to our localhost on port 16006 will be forwarded to gpu_server:6006 by gpu_server. In this way, we establish a connection between our local browser and remote tensorboard service, but the remote tensorboard service only knows that the requests are from localhost (gpu_server) which has access permission. Remote Port ForwardingIn contrast to local port forwarding, remote port forwarding aims to forward connections on remote server to our local machine. This is useful when we want to communicate with a server in a local-area network by a machine in the public network. The syntax of ssh remote port forwarding is : ssh -fNTR remote_port:localhost:local_port user@ssh_host -R is the main parameter and it is used for Remote port forwarding. Connections to remote_port on ssh_host will be forwarded to localhost:local_port. Similar to local port forwarding, the localhost in the command can be replaced by other nearhost which can be connected from our localhost machine. Note: When using remote port forwarding we need to add (or edit) GatewayPorts yes to /etc/ssh/sshd_config and restart the SSH daemon use sudo systemctl restart sshd on the ssh_host. E.g. Intranet PenetrationUsually, we may have a server in wer workplace like school or company, and it can only be connected in local-area network because it doesn’t have a public network IP address. Even if we know the public IP address of wer workplace, we still can’t connect to the server by public_IP:port for NAT exists. we need to deploy an intranet penetration in advance when we want to connect to the server from home or on vacation. Suppose: ID location IP address login user name description machine_A local area network 10.109.244.100 user_A target server machine_B public network 39.97.183.218 user_B jump server machine_C public network 103.121.208.230 user_C wer local machine When we are in local-area network, login machine_A as user_A and type ssh -fNTR 2345:localhost:22 user_B@39.97.183.218 in terminal. This will establish a connect between machine_B and machine_A and connections to machine_B:2345 will be forwarded to machine_A:22. In machine_B we should (or edit) GatewayPorts yes to /etc/ssh/sshd_config and restart the SSH daemon use sudo systemctl restart sshd.service. In machine_B run netstat -ntlp we will see port 2345 has been listened. But it will be 127.0.0.1:2345 which means only receive connections from localhost. If we run ssh user_A@39.97.183.218 -p 2345 in machine_C directly, we will receive a Connection refused message. But in machine_B, just run ssh user_A@localhost -p 2345 we can login machine_A successfully. If we want to connect to machine_A directly: Option 1: Run ssh -fNTL *:4567localhost:2345 localhost in machine_B. Then type netstat -ntlp we will see 0.0.0.0:4567 which means port 4567 can receive connections from anywhere. Then we can run ssh user_A@39.97.183.218 -p 4567 to login machine_A successfully. Option 2: Change command in step 1 to ssh -fNTR *:2345:localhost:22 user_B@39.97.183.218. In machine_B we run netstat -ntlp and will see 0.0.0.0:2345 has been listening, which means we can run ssh user_A@39.97.183.218 -p 2345 to connect to machine_A directly. SSH connection is unstable and will be closed if not be used for a long time. So we use sutossh to re-connect when the connection closed. The command we run in machine_A changed to sutossh -M 5566 -fNTR (*:)2345:localhost:22 user_B@39.97.183.218. -M means to specify a monitor port to check the connection status. When using autossh, we’d better run ssh-copy-id user_B@39.97.183.218 to copy the key to machine_B which makes sure we can login machine_B from machine_A without password. Q.A.Reference:https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work https://blog.jakuba.net/ssh-tunnel---local-remote-and-dynamic-port-forwarding/","link":"/2020/09/27/SSH-Tunnel-Local-and-Remote-Port-Forwarding/"},{"title":"conda常用命令","text":"环境相关 查看已有环境conda env list 新建环境conda create -n env_name [python=3.6]新建一个名为env_name的环境，其python版本为3.6 进入环境（对于conda 4.xx）conda activate env_name 退出环境conda deactivate 导出环境为yml（用于向别人分发环境时）conda env export &gt; environment.yml 根据yml文件创建环境conda env create -f environment.yml 删除环境conda remove -n env_name --all 重命名环境conda create --name new_name --clone old_name 默认在每次打开新的terminal时，自动进入base环境，可以将其关闭conda config --set auto_activate_base false故可将这句命令加入.zshrc/.bashrc中，自动禁止加载base环境 conda相关 更新condaconda update conda 卸载condarm -fr ~/anaconda 包相关 查看当前环境安装的包conda list [-n package_name] 搜索包conda search package_name 安装包conda install package_name[=version=build_version] 当想要安装pytorch 0.2.0 py27cuda8.0cudnn6.0_0时，使用：conda install pytorch=0.2.0=py27cuda8.0cudnn6.0_0 升级包conda update package_name 升级所有包conda update --all 卸载包conda uninstall package_name 2019双十一快乐 ☺","link":"/2019/11/11/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"conda","slug":"conda","link":"/tags/conda/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}